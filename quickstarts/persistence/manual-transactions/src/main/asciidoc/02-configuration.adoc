= Configuring the Transaction Manager

.Abstract
This chapter describes how to configure Transaction Manager in {f7} and how to use it in deployed applications.
There's a clear distinction between _configuration_, which is an administrator's activity and _referencing_, which is
just pointing the application to previously configured transaction manager.

== What is a Transaction Manager?

A transaction manager is the part of an application that is responsible for coordinating transactions across one
or more resources.

The responsibilities of the transaction manager are as follows:

* Demarcationâ€”starting and ending transactions using begin, commit, and rollback methods.
* Managing the transaction context - a transaction context contains the information that a transaction manager needs to keep track of a transaction. The transaction manager is responsible for creating transaction contexts and attaching them to the current thread.
* Coordinating the transaction across multiple resources - enterprise-level transaction managers typically have the capability to coordinate a transaction across multiple resources. This feature requires the 2-phase commit protocol and resources must be registered and managed using the XA protocol (see the section called <<X/Open XA standard,???>>).
+
This is an advanced feature, not supported by all transaction managers.
* Recovery from failure - transaction managers are responsible for ensuring that resources are not left in an inconsistent state, if there is a system failure and the application crashes. In some cases, manual intervention might be required to restore the system to a consistent state.

.Local transaction managers
A _local transaction manager_ is a transaction manager that can coordinate transactions over a single resource only. In this case, the implementation of the transaction manager is typically embedded in the resource itself and the transaction manager used by application is just a thin wrapper around this built-in transaction manager.

For example, the Oracle database has a built-in transaction manager that supports demarcation operations (using SQL operations, BEGIN, COMMIT, ROLLBACK, or using a native Oracle API) and various levels of transaction isolation. Control over the Oracle transaction manager can be exported through JDBC, and this JDBC API is used by application to demarcate transactions.

It is important to understand what constitutes a resource, in this context. For example, if you are using a JMS product, the JMS resource is the single running instance of the JMS product, not the individual queues and topics. Moreover, sometimes, what appears to be multiple resources might actually be a single resource, if the same underlying resource is accessed in different ways. For example, your application might access a relational database both directly (through JDBC) and indirectly (through an object-relational mapping tool like Hibernate). In this case, the same underlying transaction manager is involved, so it should be possible to enrol both of these code fragments in the same transaction.

NOTE: It cannot be guaranteed that this will work in every case. Although it is possible in principle, some detail in design of the Spring framework or other wrapper layers might prevent it from working in practice.

Of course, it is possible for an application to have many different local transaction managers working independently of each other. For example, you could have one Camel route that manipulates JMS queues and topics, where the JMS endpoints reference a JMS transaction manager. Another route could access a relational database through JDBC. But you could not combine JDBC and JMS access in the same route and have them both participate in the same transaction.

.Global transaction managers
A global transaction manager is a transaction manager that can coordinate transactions over multiple resources. In this case, you cannot rely on the transaction manager built into the resource itself. Instead, you require an external system, sometimes called a transaction processing monitor (TP monitor), that is capable of coordinating transactions across different resources.

The following are the prerequisites for global transactions:

* Global transaction manager or TP monitor - an external transaction system that implements the 2-phase commit protocol for coordinating multiple XA resources.
* Resources that support the _XA standard_ - in order to participate in a 2-phase commit, resources must support the <<X/Open XA standard,???>>. In practice, this means that the resource is capable of exporting an XA _switch_ object, which gives complete control of transactions to the external TP monitor.

TIP: The Spring framework does not by itself provide a TP monitor to manage global transactions. It does, however, provide support for integrating with an OSGi-provided TP monitor or with a JavaEE-provided TP monitor (where the integration is implemented by the https://docs.spring.io/spring/docs/4.3.x/javadoc-api/org/springframework/transaction/jta/JtaTransactionManager.html[JtaTransactionManager] class). Hence, if you deploy your application into an OSGi container with full transaction support, you can use multiple transactional resources in Spring.

.Distributed transaction managers
Usually, a server connects directly to the resources involved in a transaction. In a distributed system, however, it is occasionally necessary to connect to resources that are exposed only indirectly, through a Web service. In this case, you require a TP monitor that is capable of supporting distributed transactions. Several standards are available that describe how to support transactions for various distributed protocols - for example, the WS-AtomicTransactions specification for Web services.

== JavaEE Transaction API

